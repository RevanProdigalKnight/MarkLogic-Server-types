// deno-lint-ignore-file no-empty-interface ban-types
/// <reference path="../builtins/Element.d.ts" />
/// <reference path="../builtins/Node.d.ts" />
/// <reference path="../builtins/Sequence.d.ts" />

/// <reference path="./cts.d.ts" />
/// <reference path="./sec.d.ts" />
/// <reference path="./xs.d.ts" />

/// <reference path="../globals.d.ts" />

declare module 'xdmp' {
	global {
		const xdmp: MarkLogic.xdmp.XDMP;

		namespace MarkLogic.xdmp {
			type ID = number | string;
			type size_t = number | string;

			interface xdmpFunction {}

			interface validationErrors extends Element {}

			interface XDMP {
				access(uri: string, action: 'create' | 'insert' | 'update' | 'node-update' | 'execute'): boolean;
				add64(x: number | string, y: number | string): number | string;
				addResponseHeader(name: string, value: string): null;
				addResponseTrailer(name: string, value: string): null;
				amp(namespace: string, localname: string, moduleUri: string, database: ID): number | string;
				ampRoles(namespaceUri: string, localname: string, documentUri: string, databaseId: ID): Sequence;
				and64(x: number | string, y: number | string): number | string;
				apply(fn: xdmpFunction, parameters: Sequence): Sequence;
				architecture(): string;
				arrayValues<T = unknown>(arr: T[], flatten?: boolean): Sequence<T>;
				atomizable(item: unknown): boolean;
				awsRegion(): string | undefined;
				awsServicesDomain(): string | undefined;
				awsServicesPartition(): string | undefined;
				azureEnvironment(): string | undefined;
				azureRegion(): string | undefined;
				base64Decode(encoded: string): string;
				base64Encode(decoded: string): string;
				binaryDecode(encoded: Node, encoding: string): string;
				binaryIsExternal(binary: binary): boolean;
				binaryIsLarge(binary: binary): boolean;
				binaryIsSmall(binary: binary): boolean;
				binarySize(binary?: binary): size_t;
				binaryToInteger(binary?: binary): number;
				bootstrapHosts(): Sequence;
				cacheStatus(hostId: ID): Sequence;
				callerDialect(): string | undefined;
				canGrantRoles(roles: string[]): null; // Raises error if role(s) can't be granted
				castableAs(namespaceUri: string, localName: string, item: unknown): boolean;
				cluster(name?: string): ID;
				clusterEffectiveVersion(): xs.unsignedLong;
				clusterFedramp(): boolean;
				clusterName(): string;
				clusterVersionAtLeast(v: number): boolean;
				collationCanonicalUri(collationUri: string): string;
				collationLocales(): Sequence;
				collectionDelete(uri: string): null;
				collectionId(uri: string): number | string;
				collectionLocks(uris?: string[]): Sequence;
				collectionProperties(uris?: string[]): Sequence;
				collections(): Sequence;
				commit(): null;
				configurationTimestamp(filename?: string): number | string;
				credential(id: ID): sec.credential;
				credentialId(name: string): ID;
				credentials(uri: string): Sequence;
				crypt(password: string, salt: string): string;
				crypt2(password: string): string;
				database(name?: string): ID;
				databaseAssignmentPolicy(dbId: string): object;
				databaseBackup(forestIds: ID[], pathname: string, journalArchiving?: boolean, journalArchivePath?: string, lagLimit?: number | string, backupKekId?: string, backupPassphrase?: string): number | string;
				databaseBackupCancel(jobId: ID): boolean;
				databaseBackupPurge(dir: string, keepNBackups: number, incrementalDir?: string): null;
				databaseBackupStatus(jobId: ID, hostId?: ID): object;
				databaseBackupValidate(forestIds: ID[], pathname: string, includeReplicas?: boolean, journalArchiving?: boolean, journalArchivePath?: string, lagLimit?: number | string): object;
				databaseDirectoryCreation(databaseId: string): string;
				databaseEncryptionAtRest(databaseId: ID): string;
				databaseEncryptionKeyId(databaseId: ID): string;
				databaseForests(databaseId: ID, includeReplicas?: boolean): Sequence;
				databaseGlobalNonblockingTimestamp(databaseId: ID): number | string;
				databaseIncrementalBackup(forestIds: ID[], pathname: string, incrementalDir?: string, journalArchiving?: boolean, journalArchivePath?: string, lagLimit?: number | string, backupKekId?: string, backupPassphrase?: string): number | string;
				databaseIncrementalBackupValidate(forestIds: ID[], pathname: string, includeReplicas?: boolean, journalArchiving?: boolean, journalArchivePath?: string, lagLimit?: number | string): object;
				databaseIsForestRetired(databaseId: string, forestId: string): boolean;
				databaseIsRebalancerEnable(databaseId: string): boolean;
				databaseJournalArchivePurge(dir: string, incrementalDir?: string, journalArchivePath?: string): null;
				databaseName(databaseId: ID): string;
				databaseNodeQueryRolesets(nodes: Sequence, options?: string[]): Sequence;
				databaseNonblockingTimestamp(databaseId: ID): number | string;
				databasePathNamespaces(dbId: number | string): unknown[];
				databaseRestore(forestIds: ID[], pathname: string, restoreToTime?: xs.date, journalArchiving?: boolean, journalArchivePath?: string, incrementalBackup?: boolean, incrementalBackupPath?: string, backupPassphrase?: string, forestMap?: object): number | string;
				databaseRestoreCancel(jobId: ID): boolean;
				databaseRestoreStatus(jobId: ID): object;
				databaseRestoreValidate(forestIds: ID[], pathname: string, restoreToTime?: xs.date, journalArchiving?: boolean, journalArchivePath?: string, incrementalBackup?: boolean, incrementalBackupPath?: string, backupPassphrase?: string, forestMap?: object): object;
				databases(): Sequence;
				dayNameFromDate(date: xs.date): string;
				decodeFromNCName(name: string): string;
				defaultCollections(uri?: string): string;
				defaultPermissions(uri: string, outputKind: null): sec.permission;
				defaultPermissions(uri: string, outputKind: 'element'): sec.permissionElement;
				defaultPermissions(uri?: string, outputKind?: 'object'): sec.permission;
				describe(item: Sequence, maxSequenceLength?: number, maxItemLength?: number): string;
				diacriticLess(str: string): string;
				directory(uri: string, depth?: '1' | 'infinity'): Sequence;
				directoryCreate(uri: string, permissions?: object[], collections?: string[], quality?: number, forestIds?: (number | string)[], options?: object): null;
				directoryDelete(uri: string): null;
				directoryLocks(uri: string, depth?: '1' | 'infinity'): Sequence;
				directoryProperties(uri: string, depth?: '1' | 'infinity'): Sequence;
				documentAddCollections(uri: string, collections: string[]): null;
				documentAddProperties(uri: string, properties: string[]): null;
				documentAssign(uri: string, forestCount: number, assignmentPolicy?: string): number;
				documentDelete(uri: string, options?: object): null;
				documentFilter(doc: Node, options?: object): Node;
				documentForests(uri: string, forests?: (number | string)[]): number | string;
				documentGet(location: string, options?: object): Sequence;
				documentGetCollections(uri: string): string[];
				documentGetMetadata(uri: string): object;
				documentGetMetadataValue(uri: string, key: string): string;
				documentGetPermissions(uri: string, outputKind: null): sec.permission;
				documentGetPermissions(uri: string, outputKind: 'element'): sec.permissionElement;
				documentGetPermissions(uri: string, outputKind?: 'object'): sec.permission;
				documentGetProperties(uri: string, property?: xs.QName): Sequence;
				documentGetQuality(uri: string): number;
				documentInsert(uri: string, root: Node, options?: object): null;
				documentLoad(location: string, options?: object): null;
				documentLocks(uris?: string[]): Sequence;
				documentPartitionAssign(root: Node, partitionQueries?: object): number;
				documentProperties(uris?: string[]): Sequence;
				documentPutMetadata(uri: string, metadata: object): null;
				documentRemoveCollections(uri: string, collections: string[]): null;
				documentRemoveMetadata(uri: string, metadataKeys: string[]): null;
				documentRemovePermissions(uri: string, permissions: object[]): null;
				documentRemoveProperties(uri: string, propertyNames: xs.QName[]): null;
				documentSetCollections(uri: string, collections: string[]): null;
				documentSetMetadata(uri: string, metadata: object): null;
				documentSetPermissions(uri: string, permissions: object[]): null;
				documentSetProperties(uri: string, properties: Node[]): null;
				documentSetProperty(uri: string, property: Node): null;
				documentSetQuality(uri: string, quality: number): null;
				documentTimestamp(uri: string): number;
				effectiveVersion(): number | string;
				elapsedTime(): xs.dayTimeDuration;
				elementContentType(node: Node): string;
				email(message: object, options?: object): null;
				encodeForCName(name: string): string;
				encodingLanguageDetect(node: Node): unknown[];
				eval<T = unknown>(js: string, vars?: object | null, options?: object): Sequence<T>;
				excelConvert(node: Node, filename: string, options?: object): Sequence;
				externalBinary(path: string, startingLocation?: number, length?: number): binary;
				externalBinaryPath(source: binary): string;
				externalSecurity(externalSecurity: string): number | string;
				filesystemDirectory(pathname: string): unknown[];
				filesystemDirectoryCreate(pathname: string, options?: object): null;
				filesystemDirectoryDelete(pathname: string): null;
				filesystemFile(pathname: string): string;
				filesystemFileEncryptionStatus(pathname: string): object;
				filesystemFileExists(pathname: string, host?: number | string): boolean;
				filesystemFileGetTime(pathname: string): xs.dateTime[];
				filesystemFileLength(pathname: string): number | string;
				filesystemFilePath(pathname: string): string;
				filesystemFileSetTime(pathname: string, actime: xs.dateTime, modTime: xs.dateTime): string;
				foreignClusters(): Sequence;
				foreignClusterStatus(hostId: number | string, foreignClusterId: number | string): object;
				forest(name: string): number | string;
				forestBackup(forestId: number | string, pathname: string): null;
				forestBackupStatus(forestId: number | string): object;
				forestClear(forestIds: ID[]): null;
				forestCounts(forestIds: ID[], showElements?: string[], options?: string[]): Sequence;
				forestDatabaseReplicationResume(forestIds: ID[], forceBulkReplication: boolean): null;
				forestDatabaseReplicationSuspend(forestIds: ID[]): null;
				forestDatabases(forest: number | string): number | string;
				forestFailoverInfo(forestId: number | string): number | string;
				forestHost(forestId: number | string): number | string;
				forestName(forestId: number | string): string;
				forestOnline(forestId: number | string, timestamp?: number | string, isReplica?: boolean, syncingOk?: boolean): boolean;
				forestOpenReplica(forestIds: ID[]): Sequence;
				forestRestart(forestIds: ID[]): null;
				forestRestore(forestIds: ID[], pathname: string): null;
				forestRollback(forestIds: ID[], timestamp: number | string): null;
				forests(): Sequence;
				forestState(forestId: number | string): Sequence;
				forestStatus(forestIds: ID[]): Sequence;
				forestUpdatesAllowed(forestId: number | string): string;
				forestValidateReplicaIndex(forestIds: ID[], options: string[]): null;
				formatNumber(value: xs.numeric[], picture?: string, language?: string, letterValue?: string, ordChar?: string, zeroPadding?: string, groupingOperator?: string, groupingSize?: number): string;
				fromJSON(arg: Node): Sequence;
				fromJSONString(str: string): Sequence;
				function(fn: xs.QName, modulePath?: string): xdmpFunction;
				functionModule(fn: xdmpFunction): string;
				functionName(fn: xdmpFunction): xs.QName;
				functionParameterName(fn: xdmpFunction, position: number): xs.QName;
				functionParameterType(fn: xdmpFunction, position: number): string;
				functionReturnType(fn: xdmpFunction): string;
				functionSignature(fn: xdmpFunction): string;
				getCurrentRoles(): Sequence;
				getCurrentUser(): string;
				getCurrentUserId(): number | string;
				getInvokedPath(): string;
				getOriginalUrl(): string;
				getOrphanedBinaries(id: number | string): Sequence;
				getRequestBody(format?: 'xml' | 'json' | 'text' | 'binary'): object;
				getRequestClientAddress(): string;
				getRequestClientCertificate(): string;
				getRequestErrorFormat(): string;
				getRequestField(name: string, dflt?: string): object;
				getRequestFieldContentType(name: string): Sequence;
				getRequestFieldFilename(name: string): Sequence;
				getRequestFieldNames(): Sequence;
				getRequestHeader(name: string, dflt?: string): Sequence;
				getRequestHeaderNames(): Sequence;
				getRequestMethod(): string;
				getRequestPath(): string;
				getRequestPort(): number;
				getRequestProtocol(): string;
				getRequestUrl(): string;
				getRequestUser(): number | string;
				getRequestUsername(): string;
				getResponseCode(): Sequence;
				getResponseEncoding(): string;
				getServerField(name: string, dflt?: Sequence): Sequence;
				getServerFieldNames(): Sequence;
				getSessionField(name: string, dflt?: Sequence): Sequence;
				getSessionFieldNames(): Sequence;
				getTransactionMode(): string;
				getUrlRewriterPath(): string;
				group(name?: string): number | string;
				groupGetAuditEventTypeEnabled(groupId: string, eventType: string): boolean;
				groupHosts(groupId?: number | string): Sequence;
				groupName(groupId?: number | string): string;
				groupPortServers(groupId?: number | string): Sequence;
				groups(): Sequence;
				groupServers(groupId?: number | string): Sequence;
				groupTaskServer(groupId?: number | string): Sequence;
				gssServerNegotiate(token: string): object;
				gunzip(gzip: binary, options: object): Sequence;
				gzip(node: Node): binary;
				hash32(str: string): number;
				hash64(str: string): number | string;
				hasPrivilege(privileges: string[], kind: string): boolean;
				hexToInteger(hex: string): number;
				hmacMd5(secretKey: string | BinaryNode, message: string | BinaryNode, encoding?: string): string;
				hmacSha1(secretKey: string | BinaryNode, message: string | BinaryNode, encoding?: string): string;
				hmacSha256(secretKey: string | BinaryNode, message: string | BinaryNode, encoding?: string): string;
				hmacSha512(secretKey: string | BinaryNode, message: string | BinaryNode, encoding?: string): string;
				host(name?: string): number | string;
				hostForests(id: number | string): Sequence;
				hostGetSslFipsEnabled(hostIds: ID[]): Sequence<boolean>;
				hostGroup(id?: number | string): number | string;
				hostMode(): string;
				hostModeDescription(id?: number | string): string;
				hostName(id?: number | string): string;
				hosts(): Sequence<number | string>;
				hostStatus(hostIds: ID[]): Sequence;
				httpDelete(uri: string, options?: object): Sequence;
				httpGet(uri: string, options?: object): Sequence;
				httpHead(uri: string, options?: object): Sequence;
				httpOptions(uri: string, options?: object): Sequence;
				httpPost(uri: string, options?: object, data?: Node): Sequence;
				httpPut(uri: string, options?: object, data?: Node): Sequence;
				initCap(str: string): string;
				integerToBinary(n: number): string;
				integerToHex(n: number): string;
				integerToOctal(n: number): string;
				invoke<T = unknown>(path: string, vars?: object, options?: object): Sequence<T>;
				invokeFunction<T = unknown>(fn: xdmpFunction, options?: object): Sequence<T>;
				isWhitespaceNode(node?: Node): boolean;
				jsonPointer(node: Node, path: string): Node;
				jsonValidate(node: Node, schema: string, options: string[]): Node;
				jsonValidateNode(node: Node, schema: Node, options: string[]): Node;
				jsonValidateReport(node: Node, schema: string, options: string[]): object;
				jsonValidateReportNode(node: Node, schema: Node, options: string[]): object;
				keyFromName(name: xs.QName): string;
				keystoreExport(passphrase: string, filepath: string): boolean;
				keystoreImport(passphrase: string, filepath: string): boolean;
				keystoreSetCurrentHost(hostname?: string): boolean;
				keystoreSynchrosize(hostIds: ID[]): null;
				keystoreValidateExported(passphrase: string, filepath: string): Sequence;
				ldapLookup(DN: string, options?: object): Sequence;
				ldapSearch(query: string, options?: object): Sequence;
				load(path: string, uri?: string, permissions?: object[], collections?: string[], quality?: xs.int, defaultNamespace?: string, options?: string[], forestIds?: ID[]): null;
				lockAcquire(uri: string, scope?: string, depth?: string, owner?: string, timeout?: number | string): null;
				lockForUpdate(uri: string): null;
				lockRelease(uri: string): null;
				log(msg?: Sequence | object | string | unknown[] | number | boolean, level?: 'emergency' | 'alert' | 'critical' | 'error' | 'warning' | 'notice' | 'info' | 'config' | 'debug' | 'fine' | 'finer' | 'finest'): null;
				logfileScan(path: string, matchPattern: string, matchFlags: string, startDate: xs.dateTime, endDate: xs.dateTime, limit: number): Sequence;
				login(name: string, password?: string, setSession?: boolean, roleNames?: string[]): boolean;
				logLevel(): string;
				logmessageParse(messages: string[], format: string, timeZoneOffset: xs.duration): Sequence;
				logout(): null;
				lshift64(x: number | string, y: number | string): number | string;
				md5(data: string | BinaryNode, encoding?: string): string;
				merge(options?: object): null;
				mergeCancel(forestId: ID, mergeId: ID): null;
				merging(): Sequence;
				mimeTypes(): unknown[];
				modulesDatabase(): ID;
				modulesRoot(): string;
				monthNameFromDate(date: xs.date): string;
				mul64(x: number | string, y: number | string): number | string;
				multipartDecode(separator: string, data: binary, options?: Node): Sequence;
				multipartEncode(separator: string, manifest: unknown[] | Node, content: unknown[] | Sequence): binary;
				nodeCollections(node: Node): string[];
				nodeDatabase(node: Node): ID;
				nodeDelete(node: Node): null;
				nodeInsertAfter(sibling: Node, newNode: Node): null;
				nodeInsertBefore(sibling: Node, newNode: Node): null;
				nodeInsertChild(parent: Node, newNode: Node): null;
				nodeKind(node: Node): string;
				nodeMetadata(node: Node): object;
				nodeMetadataValue(node: Node, key: string): string;
				nodePermissions(node: Node, outputKind: null): sec.permission[];
				nodePermissions(node: Node, outputKind: 'element'): sec.permissionElement[];
				nodePermissions(node: Node, outputKind?: 'object'): sec.permission[];
				nodeQueryRolesets(uri: string, root: Node, insertOptions?: object, options?: string[]): Sequence;
				nodeReplace(old: Node, newNode: Node): null;
				nodeUri(node: Node): string;
				not64(x: number | string, y: number | string): number | string;
				octalToInteger(octal: string): number;
				or64(x: number | string, y: number | string): number | string;
				parseDateTime(picture: string, value: string, language?: string, calendar?: string, country?: string): xs.dateTime;
				parseYymmdd(picture: string, value: string, language?: string, calendar?: string, country?: string): xs.dateTime;
				partitionForests(partitionNumber: number): Sequence;
				passiveHasPrivilege(privileges: string[], kind: string): boolean;
				passiveSecurityAssert(privileges: string[], kind: string): null;
				path(node: Node, includeDocument?: boolean): string;
				pdfConvert(doc: Node, filename: string, options?: object): Sequence;
				permission(role: string, capability: string, outputKind: null): sec.permission;
				permission(role: string, capability: string, outputKind: 'element'): sec.permissionElement;
				permission(role: string, capability: string, outputKind?: 'object'): sec.permission;
				platform(): string;
				position(text: string, target: string, collation?: string): number;
				powerpointConvert(doc: Node, filename: string, options?: object): Sequence;
				prettyPrint(xquery: string): string;
				privilege(action: string, kind: string): ID;
				privilegeKind(privilege: ID): string;
				privilegeName(privilege: ID): string;
				privilegeRoles(action: string, kind: string): Sequence<ID>;
				privileges(): Sequence<ID>;
				productEdition(): string;
				productEnvironment(): string;
				QNameFromKey(key: string): xs.QName;
				quarterFromDate(date: xs.date): number;
				queryMeters(): object;
				queryPartitions(query: cts.query): Sequence<number>;
				queryTrace(enabled: boolean): null;
				quote(arg: Sequence | unknown[] | unknown, options?: object): string;
				random(max: number | string): number | string;
				rangePartitionForests(value: xs.anyAtomicType): Sequence<ID>;
				redirectResponse(name: string): null;
				removeOrphanedBinary(forestId: ID, binaryId: ID): null;
				request(): ID;
				requestCancel(hostId: ID, serverId: ID, requestId: ID): null;
				requestLogDelete(key: string): null;
				requestLogGet(key: string): object;
				requestLogPut(key: string, value: object): null;
				requestStatus(hostId: ID, serverId: ID, requestId: ID): Sequence;
				requestTimestamp(): number | string;
				resolveUri(relative: string, base?: string): string;
				restart(hostIds: ID[], reason: string): null;
				rethrow(): null;
				role(name: string): ID;
				roleCompartment(roleId: ID): string;
				roleDescription(roleId: ID): string;
				roleGetDefaultCollections(roleName: string): Sequence<string>;
				roleGetDefaultPermissions(roleName: string, outputKind: null): sec.permission;
				roleGetDefaultPermissions(roleName: string, outputKind: 'element'): sec.permissionElement;
				roleGetDefaultPermissions(roleName: string, outputKind?: 'object'): sec.permission;
				roleName(roleId: ID): string;
				rolePrivileges(roleId: ID): Sequence<ID>;
				roleRoles(name: string, inherit?: boolean): Sequence<ID>;
				roles(): Sequence<ID>;
				rollback(): null;
				rsaGenerate(options: object): Sequence<string>;
				rshift64(x: number | string, y: number | string): number | string;
				save(path: string, node: Node, options?: object): null;
				schemaDatabase(databaseId?: ID): ID;
				securityAssert(privileges: string[], kind: string): null;
				securityDatabase(databaseId?: ID): ID;
				server(name?: string, group?: ID): Sequence<ID>;
				serverCollation(id: ID): string;
				serverCoordinateSystem(id: ID): string;
				serverDatabase(id: ID): string;
				serverDefaultXqueryVersion(id: ID): string;
				serverGroup(id: ID): ID;
				serverKind(id: ID): string;
				serverMaxThreads(id: ID): number;
				serverModulesDatabase(databaseId?: ID): ID;
				serverName(id: ID): string;
				serverPort(id: ID): number;
				serverRoot(id: ID): string;
				servers(): Sequence<ID>;
				serverSessionTimeout(id: ID): number;
				serverSslCertificateTemplate(id: ID): ID;
				serverStatus(hostId: ID, serverIds: ID[]): Sequence;
				setRequestLimit(meterName: string, limit: number | string, hostId?: ID, serverId?: ID, requestId?: ID): null;
				setRequestTimeLimit(limit: number, hostId?: ID, serverId?: ID, requestId?: ID): null;
				setResponseChunkedEncoding(chunked: boolean): null;
				setResponseCode(code: number, message: string): null;
				setResponseCompression(compressed: boolean, options?: string): null;
				setResponseContentType(contentType: string): null;
				setResponseEncoding(encoding: string): null;
				setResponseOutputMethod(method: string): null;
				setServerField<T = unknown>(name: string, value: Sequence<T>): Sequence<T>;
				setServerFieldPrivilege(name: string, privilege: string): null;
				setSessionField<T = unknown>(name: string, value: Sequence<T>): Sequence<T>;
				setTransactionMode(value: string): null;
				setTransactionName(name: string, hostId?: ID, transactionId?: ID): null;
				setTransactionTimeLimit(limit: number, hostId?: ID, transactionId?: ID): null;
				sha1(data: string | BinaryNode, encoding?: string): string;
				sha256(data: string | BinaryNode, encoding?: string): string;
				sha384(data: string | BinaryNode, encoding?: string): string;
				sha512(data: string | BinaryNode, encoding?: string): string;
				shutdown(hostIds: ID[], reason: string, failover?: boolean): null;
				sleep(ms: number): null;
				softwareVersion(): number | string;
				spawn(path: string, vars?: object, options?: object): Sequence;
				sql(sql: string, options?: string[], bindings?: object, query?: cts.query): Sequence;
				sqlPlan(sql: string, options?: string[]): Sequence;
				startJournalArchiving(forestIds: ID[], journalArchivePath: string, lagLimit?: number | string): null;
				step64(initial: number | string, step: number | string): number | string;
				stopJournalArchiving(forestIds: ID[]): null;
				streamable(sequence: Sequence): Sequence<'future' | 'iterator' | 'concurrent'>;
				strftime(format: string, date: xs.dateTime): string;
				subbinary(source: binary, startingLocation: number, length?: number): binary;
				tidy(doc: string, options?: object): Sequence<Node>;
				timestampToWallclock(timestamp: number | string): xs.dateTime;
				toJSON(item: Sequence): Node;
				toJSONString(item: Sequence): string;
				trace(name: string, value: Sequence | string): null;
				traceEnabled(name: string): boolean;
				transaction(txName?: string, hostId?: ID): Sequence<ID>;
				transactionCommit(hostId: ID, txId: ID): null;
				transactionLocks(hostId?: ID, txId?: ID): Object;
				transactionRollback(hostId: ID, txId: ID): null;
				triggersDatabase(databaseId?: ID): ID;
				type(value: xs.anyAtomicType): xs.QName;
				unquote(arg: string, defaultNamespace?: string, options?: string[]): Sequence;
				uriContentType(uri: string): string;
				uriFormat(uri: string): string;
				uriIsFile(uri: string): boolean;
				urlDecode(encodedUrl: string | Sequence<string>): string;
				urlEncode(url: string, noSpacePlus?: boolean): string;
				user(user: string, extSecId?: ID, secDbFirst?: boolean): ID;
				userExternalSecurity(userId: ID): Object;
				userGetDefaultCollections(username: string): Sequence<string>;
				userGetDefaultPermissions(username: string, outputKind: null): sec.permission;
				userGetDefaultPermissions(username: string, outputKind: 'element'): sec.permissionElement;
				userGetDefaultPermissions(username: string, outputKind?: 'object'): sec.permission;
				useridRoles(userId: ID, extSecId?: ID, secDbFirst?: boolean): ID;
				userLastLogin(): object;
				userPrivileges(user: string, extSecId?: ID, secDbFirst?: boolean): Sequence<ID>;
				userRoles(user: string, extSecId?: ID, secDbFirst?: boolean): Sequence<ID>;
				validate(node: Node, mode?: string, typeName?: xs.QName): validationErrors;
				version(): string;
				wallclockToTimestamp(date: xs.dateTime): number | string;
				weekdayFromDate(date: xs.dateTime): number;
				weekFromDate(date: xs.dateTime): number;
				wordConvert(doc: Node, filename: string, options?: object): Sequence;
				x509CertificateExtract(cert: string): object;
				x509CertificateGenerate(cert: object, privateKey?: string, options?: object): string;
				x509CertificateIssuerName(cert: string): object;
				x509CertificateSubjectName(cert: string): object;
				xaComplete(forestId: ID, txId: ID, commit: boolean, remember: boolean): null;
				xaForget(forestId: ID, txId: ID): null;
				xor64(x: number | string, y: number | string): number | string;
				xqueryEval(xquery: string, vars?: object, options?: object): Sequence;
				xsltEval(stylesheet: Node, input?: Node, params?: object, options?: object): Sequence;
				xsltInvoke(path: Node, input?: Node, params?: object, options?: object): Sequence;
				yeardayFromDate(date: xs.dateTime): number;
				zipCreate(manifest: unknown[] | Node, nodes: unknown[] | Sequence): binary;
				zipGet(zipFile: binary, name: string, options?: object): Sequence;
				zipManifest(zipFile: binary): unknown[];
			}
		}
	}
}
